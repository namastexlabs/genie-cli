import { spawn } from 'child_process';
import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { loadConfig, getDefaultProfile, configExists } from '../lib/config.js';
import { loadGenieConfig, genieConfigExists, getGenieDir, ensureGenieDir } from '../lib/genie-config.js';
import { describeEnabledHooks, hasEnabledHooks, parseHookNames } from '../lib/hooks/index.js';
import * as tmux from '../lib/tmux.js';

const SESSION_NAME = 'genie';

export interface LaunchOptions {
  hooks?: string;
  noHooks?: boolean;
}

/**
 * Get the AGENTS.md system prompt if it exists in the current directory
 */
function getAgentsSystemPrompt(): string | null {
  const agentsPath = join(process.cwd(), 'AGENTS.md');
  if (existsSync(agentsPath)) {
    return readFileSync(agentsPath, 'utf-8');
  }
  return null;
}

/**
 * Get Claude CLI arguments including system prompt if AGENTS.md exists
 */
function getClaudeArgs(): string[] {
  const prompt = getAgentsSystemPrompt();
  if (prompt) {
    return ['--system-prompt', prompt];
  }
  return [];
}

/**
 * Get the Claude command string for shell execution
 */
function getClaudeCommand(): string {
  const prompt = getAgentsSystemPrompt();
  if (prompt) {
    // Escape for shell: replace single quotes with '\''
    const escaped = prompt.replace(/'/g, "'\\''");
    return `claude --system-prompt '${escaped}'`;
  }
  return 'claude';
}

/**
 * Display hook information before launch
 */
async function displayHookInfo(options: LaunchOptions): Promise<void> {
  // Handle --no-hooks
  if (options.noHooks) {
    console.log('\x1b[33m‚ö†Ô∏è  Hooks disabled via --no-hooks\x1b[0m');
    return;
  }

  // Handle --hooks override
  if (options.hooks) {
    const presets = parseHookNames(options.hooks);
    if (presets.length > 0) {
      console.log(`\x1b[36mü™ù Using hooks: ${presets.join(', ')}\x1b[0m`);
    }
    return;
  }

  // Load from genie config
  if (genieConfigExists()) {
    const genieConfig = await loadGenieConfig();
    if (hasEnabledHooks(genieConfig)) {
      const descriptions = describeEnabledHooks(genieConfig);
      console.log('\x1b[36mü™ù Active hooks:\x1b[0m');
      for (const desc of descriptions) {
        console.log(`   ${desc}`);
      }
    }
  }
}

/**
 * Write a shell-sourceable hooks environment file
 * This can be sourced before running claude to set up hook-related env vars
 */
async function writeHooksEnvFile(): Promise<string | null> {
  if (!genieConfigExists()) {
    return null;
  }

  const genieConfig = await loadGenieConfig();
  if (!hasEnabledHooks(genieConfig)) {
    return null;
  }

  ensureGenieDir();
  const envFile = join(getGenieDir(), 'hooks-env.sh');

  // For now, we just export a marker that hooks are configured
  // The actual hooks run in SDK applications, not the CLI
  const content = `# Genie hooks environment
# Generated by claudio launch
# This file indicates hooks are configured in ~/.genie/config.json
export GENIE_HOOKS_ENABLED="${genieConfig.hooks.enabled.join(',')}"
`;

  writeFileSync(envFile, content, 'utf-8');
  return envFile;
}

export async function launchProfile(profileName: string, options: LaunchOptions = {}): Promise<void> {
  const config = await loadConfig();
  const profile = config.profiles[profileName];

  if (!profile) {
    console.error(`‚ùå Profile "${profileName}" not found`);
    console.log(`\nAvailable profiles: ${Object.keys(config.profiles).join(', ')}`);
    process.exit(1);
  }

  // Display hook information
  await displayHookInfo(options);

  // Write hooks environment file
  const hooksEnvFile = await writeHooksEnvFile();

  const isInsideTmux = !!process.env.TMUX;

  // Environment setup command
  const envSetupParts = [
    `export LC_ALL=C.UTF-8`,
    `export LANG=C.UTF-8`,
    `export ANTHROPIC_BASE_URL="${config.apiUrl}"`,
    `export ANTHROPIC_AUTH_TOKEN="${config.apiKey}"`,
    `export ANTHROPIC_DEFAULT_OPUS_MODEL="${profile.opus}"`,
    `export ANTHROPIC_DEFAULT_SONNET_MODEL="${profile.sonnet}"`,
    `export ANTHROPIC_DEFAULT_HAIKU_MODEL="${profile.haiku}"`,
  ];

  // Source hooks env file if it exists
  if (hooksEnvFile) {
    envSetupParts.push(`source "${hooksEnvFile}"`);
  }

  envSetupParts.push(getClaudeCommand());

  const envSetup = envSetupParts.join('; ');

  if (isInsideTmux) {
    // Already inside tmux - run directly in current terminal
    console.log(`üöÄ Launching "${profileName}"...`);

    // Set environment variables
    process.env.LC_ALL = 'C.UTF-8';
    process.env.LANG = 'C.UTF-8';
    process.env.ANTHROPIC_BASE_URL = config.apiUrl;
    process.env.ANTHROPIC_AUTH_TOKEN = config.apiKey;
    process.env.ANTHROPIC_DEFAULT_OPUS_MODEL = profile.opus;
    process.env.ANTHROPIC_DEFAULT_SONNET_MODEL = profile.sonnet;
    process.env.ANTHROPIC_DEFAULT_HAIKU_MODEL = profile.haiku;

    // Spawn claude with inherited stdio (replaces this process)
    const child = spawn('claude', getClaudeArgs(), {
      stdio: 'inherit',
      env: process.env,
    });

    child.on('error', (error) => {
      console.error(`‚ùå Failed to launch: ${error.message}`);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  } else {
    // Outside tmux - create or reuse "genie" session
    let session = await tmux.findSessionByName(SESSION_NAME);

    if (session) {
      // Session exists - add a new window
      console.log(`üöÄ Adding "${profileName}" to session "${SESSION_NAME}"...`);

      const window = await tmux.createWindow(session.id, profileName);
      if (!window) {
        console.error('‚ùå Failed to create window');
        process.exit(1);
      }

      const panes = await tmux.listPanes(window.id);
      await tmux.executeCommand(panes[0].id, envSetup);
    } else {
      // No session - create it
      console.log(`üöÄ Creating session "${SESSION_NAME}" with "${profileName}"...`);

      session = await tmux.createSession(SESSION_NAME);
      if (!session) {
        console.error('‚ùå Failed to create tmux session');
        process.exit(1);
      }

      // Rename the default window to the profile name
      const windows = await tmux.listWindows(session.id);
      await tmux.renameWindow(windows[0].id, profileName);

      const panes = await tmux.listPanes(windows[0].id);
      await tmux.executeCommand(panes[0].id, envSetup);
    }

    console.log(`‚úÖ Ready`);
    console.log(`\nAttaching to session...`);

    // Attach to session
    const child = spawn('tmux', ['attach', '-t', SESSION_NAME], {
      stdio: 'inherit',
    });

    child.on('error', (error) => {
      console.error(`‚ùå Failed to attach: ${error.message}`);
      process.exit(1);
    });

    child.on('exit', (code) => {
      process.exit(code || 0);
    });
  }
}

export async function launchDefaultProfile(options: LaunchOptions = {}): Promise<void> {
  if (!configExists()) {
    console.error('‚ùå No config found. Run `claudio setup` first.');
    process.exit(1);
  }

  const defaultProfile = await getDefaultProfile();

  if (!defaultProfile) {
    console.error('‚ùå No default profile set.');
    console.log('\nRun `claudio setup` to configure, or use `claudio <profile>` to launch a specific profile.');
    process.exit(1);
  }

  await launchProfile(defaultProfile, options);
}
