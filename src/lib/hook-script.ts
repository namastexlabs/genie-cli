/**
 * Hook Script Manager
 *
 * Generates and manages the bash hook script at ~/.claude/hooks/genie-bash-hook.sh
 * This script intercepts Bash tool calls and rewrites them to go through term exec.
 */

import { existsSync, unlinkSync, writeFileSync, chmodSync } from 'fs';
import {
  ensureClaudeHooksDir,
  getGenieHookScriptPath,
  contractClaudePath,
} from './claude-settings.js';
import { loadGenieConfig } from './genie-config.js';

/**
 * Check if the hook script exists
 */
export function hookScriptExists(): boolean {
  return existsSync(getGenieHookScriptPath());
}

/**
 * Get the hook script path (re-export for convenience)
 */
export function getHookScriptPath(): string {
  return getGenieHookScriptPath();
}

/**
 * Get the hook script path for display (with ~ for home)
 */
export function getHookScriptDisplayPath(): string {
  return contractClaudePath(getGenieHookScriptPath());
}

/**
 * Generate the hook script content
 *
 * The script:
 * 1. Reads JSON from stdin (Claude Code sends hook event)
 * 2. Extracts the command from the Bash tool input
 * 3. Wraps the command in `term exec genie:shell '...'`
 * 4. Outputs JSON in Claude Code's expected format
 */
export async function generateHookScript(): Promise<string> {
  // Load config to get session/window names
  const config = await loadGenieConfig();
  const sessionName = config.hooks.collaborative?.sessionName || 'genie';
  const windowName = config.hooks.collaborative?.windowName || 'shell';
  const target = `${sessionName}:${windowName}`;

  // The bash script that will be executed by Claude Code
  // Uses jq to parse and transform the JSON
  const script = `#!/bin/bash
#
# Genie Bash Hook for Claude Code
#
# This hook intercepts Bash tool calls and rewrites them to execute
# through tmux via 'term exec', making all terminal operations visible
# in a shared tmux session.
#
# Generated by: genie hooks install
# Target session: ${target}
#

# Read the entire input from stdin
INPUT=$(cat)

# Extract the tool name to verify this is a Bash call
TOOL_NAME=$(echo "$INPUT" | jq -r '.tool_name // empty')

# If not a Bash tool call, allow it to proceed unchanged
if [ "$TOOL_NAME" != "Bash" ]; then
  echo '{"hookSpecificOutput":{"hookEventName":"PreToolUse","permissionDecision":"allow"}}'
  exit 0
fi

# Extract the command from the tool input
COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command // empty')

# If no command, allow it (shouldn't happen but be safe)
if [ -z "$COMMAND" ]; then
  echo '{"hookSpecificOutput":{"hookEventName":"PreToolUse","permissionDecision":"allow"}}'
  exit 0
fi

# Escape single quotes in the command for safe shell embedding
# Replace ' with '\\'\\''
ESCAPED_COMMAND=$(echo "$COMMAND" | sed "s/'/'\\\\'\\\\''/" )

# Build the wrapped command that goes through term exec
WRAPPED_COMMAND="term exec ${target} '\${ESCAPED_COMMAND}'"

# Extract other fields from the original input to preserve them
TIMEOUT=$(echo "$INPUT" | jq -r '.tool_input.timeout // empty')
DESCRIPTION=$(echo "$INPUT" | jq -r '.tool_input.description // empty')
RUN_IN_BACKGROUND=$(echo "$INPUT" | jq -r '.tool_input.run_in_background // empty')

# Build the updated input object
UPDATED_INPUT=$(jq -n \\
  --arg cmd "$WRAPPED_COMMAND" \\
  --arg timeout "$TIMEOUT" \\
  --arg desc "$DESCRIPTION" \\
  --arg background "$RUN_IN_BACKGROUND" \\
  '{
    command: $cmd,
    timeout: (if $timeout != "" then ($timeout | tonumber) else null end),
    description: (if $desc != "" then ("[term] " + $desc) else null end),
    run_in_background: (if $background == "true" then true elif $background == "false" then false else null end)
  } | with_entries(select(.value != null))')

# Output the hook response in the correct format
jq -n \\
  --argjson updatedInput "$UPDATED_INPUT" \\
  '{
    "hookSpecificOutput": {
      "hookEventName": "PreToolUse",
      "permissionDecision": "allow",
      "updatedInput": $updatedInput,
      "additionalContext": "Human can observe: tmux attach -t ${sessionName}"
    }
  }'
`;

  return script;
}

/**
 * Write the hook script to disk
 */
export async function writeHookScript(): Promise<void> {
  ensureClaudeHooksDir();

  const scriptPath = getGenieHookScriptPath();
  const scriptContent = await generateHookScript();

  writeFileSync(scriptPath, scriptContent, 'utf-8');

  // Make the script executable
  chmodSync(scriptPath, 0o755);
}

/**
 * Remove the hook script from disk
 */
export function removeHookScript(): void {
  const scriptPath = getGenieHookScriptPath();
  if (existsSync(scriptPath)) {
    unlinkSync(scriptPath);
  }
}

/**
 * Test the hook script with sample input
 * Returns { success: boolean, output?: string, error?: string }
 */
export async function testHookScript(): Promise<{
  success: boolean;
  output?: string;
  error?: string;
}> {
  const scriptPath = getGenieHookScriptPath();

  if (!existsSync(scriptPath)) {
    return {
      success: false,
      error: 'Hook script not found. Run "genie hooks install" first.',
    };
  }

  // Sample input that mimics what Claude Code sends
  const sampleInput = JSON.stringify({
    hook_event_name: 'PreToolUse',
    tool_name: 'Bash',
    tool_input: {
      command: 'echo "Hello, World!"',
      description: 'Test command',
    },
  });

  try {
    const { $ } = await import('bun');

    // Run the script with sample input
    const result = await $`echo ${sampleInput} | ${scriptPath}`.quiet();

    if (result.exitCode !== 0) {
      return {
        success: false,
        error: `Script exited with code ${result.exitCode}`,
        output: result.stderr.toString(),
      };
    }

    const output = result.stdout.toString().trim();

    // Try to parse the output as JSON
    try {
      const parsed = JSON.parse(output);

      // Validate the structure
      if (!parsed.hookSpecificOutput) {
        return {
          success: false,
          error: 'Output missing hookSpecificOutput field',
          output,
        };
      }

      if (parsed.hookSpecificOutput.hookEventName !== 'PreToolUse') {
        return {
          success: false,
          error: 'Output has wrong hookEventName',
          output,
        };
      }

      if (!['allow', 'deny', 'ask'].includes(parsed.hookSpecificOutput.permissionDecision)) {
        return {
          success: false,
          error: 'Output has invalid permissionDecision',
          output,
        };
      }

      // Check that the command was wrapped
      if (parsed.hookSpecificOutput.updatedInput?.command) {
        const cmd = parsed.hookSpecificOutput.updatedInput.command;
        if (!cmd.includes('term exec')) {
          return {
            success: false,
            error: 'Command was not wrapped with term exec',
            output,
          };
        }
      }

      return {
        success: true,
        output,
      };
    } catch (parseError: any) {
      return {
        success: false,
        error: `Output is not valid JSON: ${parseError.message}`,
        output,
      };
    }
  } catch (error: any) {
    return {
      success: false,
      error: `Failed to run hook script: ${error.message}`,
    };
  }
}
